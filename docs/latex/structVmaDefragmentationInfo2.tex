\hypertarget{structVmaDefragmentationInfo2}{}\section{Vma\+Defragmentation\+Info2 Struct Reference}
\label{structVmaDefragmentationInfo2}\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}


Parameters for defragmentation.  




{\ttfamily \#include $<$vk\+\_\+mem\+\_\+alloc.\+h$>$}



Collaboration diagram for Vma\+Defragmentation\+Info2\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=234pt]{structVmaDefragmentationInfo2__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{structVmaDefragmentationInfo2_a53e844ee5633e229cf6daf14b2d9fff9}\label{structVmaDefragmentationInfo2_a53e844ee5633e229cf6daf14b2d9fff9}} 
Vma\+Defragmentation\+Flags \hyperlink{structVmaDefragmentationInfo2_a53e844ee5633e229cf6daf14b2d9fff9}{flags}
\begin{DoxyCompactList}\small\item\em Reserved for future use. Should be 0. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structVmaDefragmentationInfo2_a3cf86ab32c1da779b4923d301a3056ba}\label{structVmaDefragmentationInfo2_a3cf86ab32c1da779b4923d301a3056ba}} 
uint32\+\_\+t \hyperlink{structVmaDefragmentationInfo2_a3cf86ab32c1da779b4923d301a3056ba}{allocation\+Count}
\begin{DoxyCompactList}\small\item\em Number of allocations in {\ttfamily p\+Allocations} array. \end{DoxyCompactList}\item 
\hyperlink{structVmaAllocation}{Vma\+Allocation} $\ast$ \hyperlink{structVmaDefragmentationInfo2_a8943f8d65969ce8e2189a1cdf3205e96}{p\+Allocations}
\begin{DoxyCompactList}\small\item\em Pointer to array of allocations that can be defragmented. \end{DoxyCompactList}\item 
Vk\+Bool32 $\ast$ \hyperlink{structVmaDefragmentationInfo2_a76d51a644dc7f5405d0cdd0025ecd0cc}{p\+Allocations\+Changed}
\begin{DoxyCompactList}\small\item\em Optional, output. Pointer to array that will be filled with information whether the allocation at certain index has been changed during defragmentation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structVmaDefragmentationInfo2_a7e70aa2a1081d849dcc7829b19d3ec9d}\label{structVmaDefragmentationInfo2_a7e70aa2a1081d849dcc7829b19d3ec9d}} 
uint32\+\_\+t \hyperlink{structVmaDefragmentationInfo2_a7e70aa2a1081d849dcc7829b19d3ec9d}{pool\+Count}
\begin{DoxyCompactList}\small\item\em Numer of pools in {\ttfamily p\+Pools} array. \end{DoxyCompactList}\item 
\hyperlink{structVmaPool}{Vma\+Pool} $\ast$ \hyperlink{structVmaDefragmentationInfo2_a0b3effd57f3fcdeb2ed62210b4ef20e1}{p\+Pools}
\begin{DoxyCompactList}\small\item\em Either null or pointer to array of pools to be defragmented. \end{DoxyCompactList}\item 
Vk\+Device\+Size \hyperlink{structVmaDefragmentationInfo2_af78e1ea40c22d85137b65f6b384a4d0a}{max\+Cpu\+Bytes\+To\+Move}
\begin{DoxyCompactList}\small\item\em Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on C\+PU side, like {\ttfamily memcpy()}, {\ttfamily memmove()}. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{structVmaDefragmentationInfo2_a94c2c7223d52878445a8cccce396b671}{max\+Cpu\+Allocations\+To\+Move}
\begin{DoxyCompactList}\small\item\em Maximum number of allocations that can be moved to a different place using transfers on C\+PU side, like {\ttfamily memcpy()}, {\ttfamily memmove()}. \end{DoxyCompactList}\item 
Vk\+Device\+Size \hyperlink{structVmaDefragmentationInfo2_a4ddbc898d0afe1518f863a3763628f08}{max\+Gpu\+Bytes\+To\+Move}
\begin{DoxyCompactList}\small\item\em Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on G\+PU side, posted to {\ttfamily command\+Buffer}. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{structVmaDefragmentationInfo2_a40d53d33e71ba0b66f844ed63c05a3f6}{max\+Gpu\+Allocations\+To\+Move}
\begin{DoxyCompactList}\small\item\em Maximum number of allocations that can be moved to a different place using transfers on G\+PU side, posted to {\ttfamily command\+Buffer}. \end{DoxyCompactList}\item 
Vk\+Command\+Buffer \hyperlink{structVmaDefragmentationInfo2_a7f71f39590c5316771493d2333f9c1bd}{command\+Buffer}
\begin{DoxyCompactList}\small\item\em Optional. Command buffer where G\+PU copy commands will be posted. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Parameters for defragmentation. 

To be used with function vma\+Defragmentation\+Begin(). 

\subsection{Member Data Documentation}
\mbox{\Hypertarget{structVmaDefragmentationInfo2_a7f71f39590c5316771493d2333f9c1bd}\label{structVmaDefragmentationInfo2_a7f71f39590c5316771493d2333f9c1bd}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!command\+Buffer@{command\+Buffer}}
\index{command\+Buffer@{command\+Buffer}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{command\+Buffer}{commandBuffer}}
{\footnotesize\ttfamily Vk\+Command\+Buffer Vma\+Defragmentation\+Info2\+::command\+Buffer}



Optional. Command buffer where G\+PU copy commands will be posted. 

If not null, it must be a valid command buffer handle that supports Transfer queue type. It must be in the recording state and outside of a render pass instance. You need to submit it and make sure it finished execution before calling vma\+Defragmentation\+End().

Passing null means that only C\+PU defragmentation will be performed. \mbox{\Hypertarget{structVmaDefragmentationInfo2_a94c2c7223d52878445a8cccce396b671}\label{structVmaDefragmentationInfo2_a94c2c7223d52878445a8cccce396b671}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!max\+Cpu\+Allocations\+To\+Move@{max\+Cpu\+Allocations\+To\+Move}}
\index{max\+Cpu\+Allocations\+To\+Move@{max\+Cpu\+Allocations\+To\+Move}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{max\+Cpu\+Allocations\+To\+Move}{maxCpuAllocationsToMove}}
{\footnotesize\ttfamily uint32\+\_\+t Vma\+Defragmentation\+Info2\+::max\+Cpu\+Allocations\+To\+Move}



Maximum number of allocations that can be moved to a different place using transfers on C\+PU side, like {\ttfamily memcpy()}, {\ttfamily memmove()}. 

{\ttfamily U\+I\+N\+T32\+\_\+\+M\+AX} means no limit. \mbox{\Hypertarget{structVmaDefragmentationInfo2_af78e1ea40c22d85137b65f6b384a4d0a}\label{structVmaDefragmentationInfo2_af78e1ea40c22d85137b65f6b384a4d0a}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!max\+Cpu\+Bytes\+To\+Move@{max\+Cpu\+Bytes\+To\+Move}}
\index{max\+Cpu\+Bytes\+To\+Move@{max\+Cpu\+Bytes\+To\+Move}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{max\+Cpu\+Bytes\+To\+Move}{maxCpuBytesToMove}}
{\footnotesize\ttfamily Vk\+Device\+Size Vma\+Defragmentation\+Info2\+::max\+Cpu\+Bytes\+To\+Move}



Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on C\+PU side, like {\ttfamily memcpy()}, {\ttfamily memmove()}. 

{\ttfamily V\+K\+\_\+\+W\+H\+O\+L\+E\+\_\+\+S\+I\+ZE} means no limit. \mbox{\Hypertarget{structVmaDefragmentationInfo2_a40d53d33e71ba0b66f844ed63c05a3f6}\label{structVmaDefragmentationInfo2_a40d53d33e71ba0b66f844ed63c05a3f6}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!max\+Gpu\+Allocations\+To\+Move@{max\+Gpu\+Allocations\+To\+Move}}
\index{max\+Gpu\+Allocations\+To\+Move@{max\+Gpu\+Allocations\+To\+Move}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{max\+Gpu\+Allocations\+To\+Move}{maxGpuAllocationsToMove}}
{\footnotesize\ttfamily uint32\+\_\+t Vma\+Defragmentation\+Info2\+::max\+Gpu\+Allocations\+To\+Move}



Maximum number of allocations that can be moved to a different place using transfers on G\+PU side, posted to {\ttfamily command\+Buffer}. 

{\ttfamily U\+I\+N\+T32\+\_\+\+M\+AX} means no limit. \mbox{\Hypertarget{structVmaDefragmentationInfo2_a4ddbc898d0afe1518f863a3763628f08}\label{structVmaDefragmentationInfo2_a4ddbc898d0afe1518f863a3763628f08}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!max\+Gpu\+Bytes\+To\+Move@{max\+Gpu\+Bytes\+To\+Move}}
\index{max\+Gpu\+Bytes\+To\+Move@{max\+Gpu\+Bytes\+To\+Move}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{max\+Gpu\+Bytes\+To\+Move}{maxGpuBytesToMove}}
{\footnotesize\ttfamily Vk\+Device\+Size Vma\+Defragmentation\+Info2\+::max\+Gpu\+Bytes\+To\+Move}



Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on G\+PU side, posted to {\ttfamily command\+Buffer}. 

{\ttfamily V\+K\+\_\+\+W\+H\+O\+L\+E\+\_\+\+S\+I\+ZE} means no limit. \mbox{\Hypertarget{structVmaDefragmentationInfo2_a8943f8d65969ce8e2189a1cdf3205e96}\label{structVmaDefragmentationInfo2_a8943f8d65969ce8e2189a1cdf3205e96}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!p\+Allocations@{p\+Allocations}}
\index{p\+Allocations@{p\+Allocations}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{p\+Allocations}{pAllocations}}
{\footnotesize\ttfamily \hyperlink{structVmaAllocation}{Vma\+Allocation}$\ast$ Vma\+Defragmentation\+Info2\+::p\+Allocations}



Pointer to array of allocations that can be defragmented. 

The array should have {\ttfamily allocation\+Count} elements. The array should not contain nulls. Elements in the array should be unique -\/ same allocation cannot occur twice. It is safe to pass allocations that are in the lost state -\/ they are ignored. All allocations not present in this array are considered non-\/moveable during this defragmentation. \mbox{\Hypertarget{structVmaDefragmentationInfo2_a76d51a644dc7f5405d0cdd0025ecd0cc}\label{structVmaDefragmentationInfo2_a76d51a644dc7f5405d0cdd0025ecd0cc}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!p\+Allocations\+Changed@{p\+Allocations\+Changed}}
\index{p\+Allocations\+Changed@{p\+Allocations\+Changed}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{p\+Allocations\+Changed}{pAllocationsChanged}}
{\footnotesize\ttfamily Vk\+Bool32$\ast$ Vma\+Defragmentation\+Info2\+::p\+Allocations\+Changed}



Optional, output. Pointer to array that will be filled with information whether the allocation at certain index has been changed during defragmentation. 

The array should have {\ttfamily allocation\+Count} elements. You can pass null if you are not interested in this information. \mbox{\Hypertarget{structVmaDefragmentationInfo2_a0b3effd57f3fcdeb2ed62210b4ef20e1}\label{structVmaDefragmentationInfo2_a0b3effd57f3fcdeb2ed62210b4ef20e1}} 
\index{Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}!p\+Pools@{p\+Pools}}
\index{p\+Pools@{p\+Pools}!Vma\+Defragmentation\+Info2@{Vma\+Defragmentation\+Info2}}
\subsubsection{\texorpdfstring{p\+Pools}{pPools}}
{\footnotesize\ttfamily \hyperlink{structVmaPool}{Vma\+Pool}$\ast$ Vma\+Defragmentation\+Info2\+::p\+Pools}



Either null or pointer to array of pools to be defragmented. 

All the allocations in the specified pools can be moved during defragmentation and there is no way to check if they were really moved as in {\ttfamily p\+Allocations\+Changed}, so you must query all the allocations in all these pools for new {\ttfamily Vk\+Device\+Memory} and offset using vma\+Get\+Allocation\+Info() if you might need to recreate buffers and images bound to them.

The array should have {\ttfamily pool\+Count} elements. The array should not contain nulls. Elements in the array should be unique -\/ same pool cannot occur twice.

Using this array is equivalent to specifying all allocations from the pools in {\ttfamily p\+Allocations}. It might be more efficient. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Blaze/thirdparty/vma/vk\+\_\+mem\+\_\+alloc.\+h\end{DoxyCompactItemize}
