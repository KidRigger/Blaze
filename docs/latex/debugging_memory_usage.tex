If you suspect a bug with memory usage, like usage of uninitialized memory or memory being overwritten out of bounds of an allocation, you can use debug features of this library to verify this.\hypertarget{debugging_memory_usage_debugging_memory_usage_initialization}{}\section{Memory initialization}\label{debugging_memory_usage_debugging_memory_usage_initialization}
If you experience a bug with incorrect and nondeterministic data in your program and you suspect uninitialized memory to be used, you can enable automatic memory initialization to verify this. To do it, define macro {\ttfamily V\+M\+A\+\_\+\+D\+E\+B\+U\+G\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+NS} to 1.


\begin{DoxyCode}
\textcolor{preprocessor}{#define VMA\_DEBUG\_INITIALIZE\_ALLOCATIONS 1}
\textcolor{preprocessor}{#include "vk\_mem\_alloc.h"}
\end{DoxyCode}


It makes memory of all new allocations initialized to bit pattern {\ttfamily 0x\+D\+C\+D\+C\+D\+C\+DC}. Before an allocation is destroyed, its memory is filled with bit pattern {\ttfamily 0x\+E\+F\+E\+F\+E\+F\+EF}. Memory is automatically mapped and unmapped if necessary.

If you find these values while debugging your program, good chances are that you incorrectly read Vulkan memory that is allocated but not initialized, or already freed, respectively.

Memory initialization works only with memory types that are {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE}. It works also with dedicated allocations. It doesn\textquotesingle{}t work with allocations created with \#\+V\+M\+A\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+C\+A\+N\+\_\+\+B\+E\+C\+O\+M\+E\+\_\+\+L\+O\+S\+T\+\_\+\+B\+IT flag, as they cannot be mapped.\hypertarget{debugging_memory_usage_debugging_memory_usage_margins}{}\section{Margins}\label{debugging_memory_usage_debugging_memory_usage_margins}
By default, allocations are laid out in memory blocks next to each other if possible (considering required alignment, {\ttfamily buffer\+Image\+Granularity}, and {\ttfamily non\+Coherent\+Atom\+Size}).



Define macro {\ttfamily V\+M\+A\+\_\+\+D\+E\+B\+U\+G\+\_\+\+M\+A\+R\+G\+IN} to some non-\/zero value (e.\+g. 16) to enforce specified number of bytes as a margin before and after every allocation.


\begin{DoxyCode}
\textcolor{preprocessor}{#define VMA\_DEBUG\_MARGIN 16}
\textcolor{preprocessor}{#include "vk\_mem\_alloc.h"}
\end{DoxyCode}




If your bug goes away after enabling margins, it means it may be caused by memory being overwritten outside of allocation boundaries. It is not 100\% certain though. Change in application behavior may also be caused by different order and distribution of allocations across memory blocks after margins are applied.

The margin is applied also before first and after last allocation in a block. It may occur only once between two adjacent allocations.

Margins work with all types of memory.

Margin is applied only to allocations made out of memory blocks and not to dedicated allocations, which have their own memory block of specific size. It is thus not applied to allocations made using \#\+V\+M\+A\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+D\+E\+D\+I\+C\+A\+T\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+B\+IT flag or those automatically decided to put into dedicated allocations, e.\+g. due to its large size or recommended by V\+K\+\_\+\+K\+H\+R\+\_\+dedicated\+\_\+allocation extension. Margins are also not active in custom pools created with \#\+V\+M\+A\+\_\+\+P\+O\+O\+L\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+B\+U\+D\+D\+Y\+\_\+\+A\+L\+G\+O\+R\+I\+T\+H\+M\+\_\+\+B\+IT flag.

Margins appear in \hyperlink{statistics_statistics_json_dump}{J\+S\+ON dump} as part of free space.

Note that enabling margins increases memory usage and fragmentation.\hypertarget{debugging_memory_usage_debugging_memory_usage_corruption_detection}{}\section{Corruption detection}\label{debugging_memory_usage_debugging_memory_usage_corruption_detection}
You can additionally define macro {\ttfamily V\+M\+A\+\_\+\+D\+E\+B\+U\+G\+\_\+\+D\+E\+T\+E\+C\+T\+\_\+\+C\+O\+R\+R\+U\+P\+T\+I\+ON} to 1 to enable validation of contents of the margins.


\begin{DoxyCode}
\textcolor{preprocessor}{#define VMA\_DEBUG\_MARGIN 16}
\textcolor{preprocessor}{#define VMA\_DEBUG\_DETECT\_CORRUPTION 1}
\textcolor{preprocessor}{#include "vk\_mem\_alloc.h"}
\end{DoxyCode}


When this feature is enabled, number of bytes specified as {\ttfamily V\+M\+A\+\_\+\+D\+E\+B\+U\+G\+\_\+\+M\+A\+R\+G\+IN} (it must be multiply of 4) before and after every allocation is filled with a magic number. This idea is also know as \char`\"{}canary\char`\"{}. Memory is automatically mapped and unmapped if necessary.

This number is validated automatically when the allocation is destroyed. If it\textquotesingle{}s not equal to the expected value, {\ttfamily V\+M\+A\+\_\+\+A\+S\+S\+E\+R\+T()} is executed. It clearly means that either C\+PU or G\+PU overwritten the memory outside of boundaries of the allocation, which indicates a serious bug.

You can also explicitly request checking margins of all allocations in all memory blocks that belong to specified memory types by using function vma\+Check\+Corruption(), or in memory blocks that belong to specified custom pool, by using function vma\+Check\+Pool\+Corruption().

Margin validation (corruption detection) works only for memory types that are {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE} and {\ttfamily H\+O\+S\+T\+\_\+\+C\+O\+H\+E\+R\+E\+NT}. 