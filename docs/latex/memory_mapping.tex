To \char`\"{}map memory\char`\"{} in Vulkan means to obtain a C\+PU pointer to {\ttfamily Vk\+Device\+Memory}, to be able to read from it or write to it in C\+PU code. Mapping is possible only of memory allocated from a memory type that has {\ttfamily V\+K\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+P\+R\+O\+P\+E\+R\+T\+Y\+\_\+\+H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+L\+E\+\_\+\+B\+IT} flag. Functions {\ttfamily vk\+Map\+Memory()}, {\ttfamily vk\+Unmap\+Memory()} are designed for this purpose. You can use them directly with memory allocated by this library, but it is not recommended because of following issue\+: Mapping the same {\ttfamily Vk\+Device\+Memory} block multiple times is illegal -\/ only one mapping at a time is allowed. This includes mapping disjoint regions. Mapping is not reference-\/counted internally by Vulkan. Because of this, Vulkan Memory Allocator provides following facilities\+:\hypertarget{memory_mapping_memory_mapping_mapping_functions}{}\section{Mapping functions}\label{memory_mapping_memory_mapping_mapping_functions}
The library provides following functions for mapping of a specific \hyperlink{structVmaAllocation}{Vma\+Allocation}\+: vma\+Map\+Memory(), vma\+Unmap\+Memory(). They are safer and more convenient to use than standard Vulkan functions. You can map an allocation multiple times simultaneously -\/ mapping is reference-\/counted internally. You can also map different allocations simultaneously regardless of whether they use the same {\ttfamily Vk\+Device\+Memory} block. The way it\textquotesingle{}s implemented is that the library always maps entire memory block, not just region of the allocation. For further details, see description of vma\+Map\+Memory() function. Example\+:


\begin{DoxyCode}
\textcolor{comment}{// Having these objects initialized:}

\textcolor{keyword}{struct }ConstantBuffer
\{
    ...
\};
ConstantBuffer constantBufferData;

\hyperlink{structVmaAllocator}{VmaAllocator} allocator;
VkBuffer constantBuffer;
\hyperlink{structVmaAllocation}{VmaAllocation} constantBufferAllocation;

\textcolor{comment}{// You can map and fill your buffer using following code:}

\textcolor{keywordtype}{void}* mappedData;
vmaMapMemory(allocator, constantBufferAllocation, &mappedData);
memcpy(mappedData, &constantBufferData, \textcolor{keyword}{sizeof}(constantBufferData));
vmaUnmapMemory(allocator, constantBufferAllocation);
\end{DoxyCode}


When mapping, you may see a warning from Vulkan validation layer similar to this one\+:

{\itshape Mapping an image with layout V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+D\+E\+P\+T\+H\+\_\+\+S\+T\+E\+N\+C\+I\+L\+\_\+\+A\+T\+T\+A\+C\+H\+M\+E\+N\+T\+\_\+\+O\+P\+T\+I\+M\+AL can result in undefined behavior if this memory is used by the device. Only G\+E\+N\+E\+R\+AL or P\+R\+E\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+ED should be used.}

It happens because the library maps entire {\ttfamily Vk\+Device\+Memory} block, where different types of images and buffers may end up together, especially on G\+P\+Us with unified memory like Intel. You can safely ignore it if you are sure you access only memory of the intended object that you wanted to map.\hypertarget{memory_mapping_memory_mapping_persistently_mapped_memory}{}\section{Persistently mapped memory}\label{memory_mapping_memory_mapping_persistently_mapped_memory}
Kepping your memory persistently mapped is generally OK in Vulkan. You don\textquotesingle{}t need to unmap it before using its data on the G\+PU. The library provides a special feature designed for that\+: Allocations made with \#\+V\+M\+A\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+M\+A\+P\+P\+E\+D\+\_\+\+B\+IT flag set in \hyperlink{structVmaAllocationCreateInfo_add09658ac14fe290ace25470ddd6d41b}{Vma\+Allocation\+Create\+Info\+::flags} stay mapped all the time, so you can just access C\+PU pointer to it any time without a need to call any \char`\"{}map\char`\"{} or \char`\"{}unmap\char`\"{} function. Example\+:


\begin{DoxyCode}
VkBufferCreateInfo bufCreateInfo = \{ VK\_STRUCTURE\_TYPE\_BUFFER\_CREATE\_INFO \};
bufCreateInfo.size = \textcolor{keyword}{sizeof}(ConstantBuffer);
bufCreateInfo.usage = VK\_BUFFER\_USAGE\_TRANSFER\_SRC\_BIT;

\hyperlink{structVmaAllocationCreateInfo}{VmaAllocationCreateInfo} allocCreateInfo = \{\};
allocCreateInfo.\hyperlink{structVmaAllocationCreateInfo_accb8b06b1f677d858cb9af20705fa910}{usage} = VMA\_MEMORY\_USAGE\_CPU\_ONLY;
allocCreateInfo.\hyperlink{structVmaAllocationCreateInfo_add09658ac14fe290ace25470ddd6d41b}{flags} = VMA\_ALLOCATION\_CREATE\_MAPPED\_BIT;

VkBuffer buf;
\hyperlink{structVmaAllocation}{VmaAllocation} alloc;
\hyperlink{structVmaAllocationInfo}{VmaAllocationInfo} allocInfo;
vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);

\textcolor{comment}{// Buffer is already mapped. You can access its memory.}
memcpy(allocInfo.\hyperlink{structVmaAllocationInfo_a5eeffbe2d2f30f53370ff14aefbadbe2}{pMappedData}, &constantBufferData, \textcolor{keyword}{sizeof}(constantBufferData));
\end{DoxyCode}


There are some exceptions though, when you should consider mapping memory only for a short period of time\+:


\begin{DoxyItemize}
\item When operating system is Windows 7 or 8.\+x (Windows 10 is not affected because it uses W\+D\+D\+M2), device is discrete A\+MD G\+PU, and memory type is the special 256 MiB pool of {\ttfamily D\+E\+V\+I\+C\+E\+\_\+\+L\+O\+C\+AL + H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE} memory (selected when you use \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+T\+O\+\_\+\+G\+PU), then whenever a memory block allocated from this memory type stays mapped for the time of any call to {\ttfamily vk\+Queue\+Submit()} or {\ttfamily vk\+Queue\+Present\+K\+H\+R()}, this block is migrated by W\+D\+DM to system R\+AM, which degrades performance. It doesn\textquotesingle{}t matter if that particular memory block is actually used by the command buffer being submitted.
\item On Mac/\+Molten\+VK there is a known bug -\/ \href{https://github.com/KhronosGroup/MoltenVK/issues/175}{\tt Issue \#175} which requires unmapping before G\+PU can see updated texture.
\item Keeping many large memory blocks mapped may impact performance or stability of some debugging tools.
\end{DoxyItemize}\hypertarget{memory_mapping_memory_mapping_cache_control}{}\section{Cache control}\label{memory_mapping_memory_mapping_cache_control}
Memory in Vulkan doesn\textquotesingle{}t need to be unmapped before using it on G\+PU, but unless a memory types has {\ttfamily V\+K\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+P\+R\+O\+P\+E\+R\+T\+Y\+\_\+\+H\+O\+S\+T\+\_\+\+C\+O\+H\+E\+R\+E\+N\+T\+\_\+\+B\+IT} flag set, you need to manually invalidate cache before reading of mapped pointer and flush cache after writing to mapped pointer. Vulkan provides following functions for this purpose {\ttfamily vk\+Flush\+Mapped\+Memory\+Ranges()}, {\ttfamily vk\+Invalidate\+Mapped\+Memory\+Ranges()}, but this library provides more convenient functions that refer to given allocation object\+: vma\+Flush\+Allocation(), vma\+Invalidate\+Allocation().

Regions of memory specified for flush/invalidate must be aligned to {\ttfamily Vk\+Physical\+Device\+Limits\+::non\+Coherent\+Atom\+Size}. This is automatically ensured by the library. In any memory type that is {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE} but not {\ttfamily H\+O\+S\+T\+\_\+\+C\+O\+H\+E\+R\+E\+NT}, all allocations within blocks are aligned to this value, so their offsets are always multiply of {\ttfamily non\+Coherent\+Atom\+Size} and two different allocations never share same \char`\"{}line\char`\"{} of this size.

Please note that memory allocated with \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+O\+N\+LY is guaranteed to be {\ttfamily H\+O\+S\+T\+\_\+\+C\+O\+H\+E\+R\+E\+NT}.

Also, Windows drivers from all 3 PC G\+PU vendors (A\+MD, Intel, N\+V\+I\+D\+IA) currently provide {\ttfamily H\+O\+S\+T\+\_\+\+C\+O\+H\+E\+R\+E\+NT} flag on all memory types that are {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE}, so on this platform you may not need to bother.\hypertarget{memory_mapping_memory_mapping_finding_if_memory_mappable}{}\section{Finding out if memory is mappable}\label{memory_mapping_memory_mapping_finding_if_memory_mappable}
It may happen that your allocation ends up in memory that is {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE} (available for mapping) despite it wasn\textquotesingle{}t explicitly requested. For example, application may work on integrated graphics with unified memory (like Intel) or allocation from video memory might have failed, so the library chose system memory as fallback.

You can detect this case and map such allocation to access its memory on C\+PU directly, instead of launching a transfer operation. In order to do that\+: inspect {\ttfamily alloc\+Info.\+memory\+Type}, call vma\+Get\+Memory\+Type\+Properties(), and look for {\ttfamily V\+K\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+P\+R\+O\+P\+E\+R\+T\+Y\+\_\+\+H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+L\+E\+\_\+\+B\+IT} flag in properties of that memory type.


\begin{DoxyCode}
VkBufferCreateInfo bufCreateInfo = \{ VK\_STRUCTURE\_TYPE\_BUFFER\_CREATE\_INFO \};
bufCreateInfo.size = \textcolor{keyword}{sizeof}(ConstantBuffer);
bufCreateInfo.usage = VK\_BUFFER\_USAGE\_UNIFORM\_BUFFER\_BIT | VK\_BUFFER\_USAGE\_TRANSFER\_DST\_BIT;

\hyperlink{structVmaAllocationCreateInfo}{VmaAllocationCreateInfo} allocCreateInfo = \{\};
allocCreateInfo.\hyperlink{structVmaAllocationCreateInfo_accb8b06b1f677d858cb9af20705fa910}{usage} = VMA\_MEMORY\_USAGE\_GPU\_ONLY;
allocCreateInfo.\hyperlink{structVmaAllocationCreateInfo_a7fe8d81a1ad10b2a2faacacee5b15d6d}{preferredFlags} = VK\_MEMORY\_PROPERTY\_HOST\_VISIBLE\_BIT;

VkBuffer buf;
\hyperlink{structVmaAllocation}{VmaAllocation} alloc;
\hyperlink{structVmaAllocationInfo}{VmaAllocationInfo} allocInfo;
vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);

VkMemoryPropertyFlags memFlags;
vmaGetMemoryTypeProperties(allocator, allocInfo.\hyperlink{structVmaAllocationInfo_a7f6b0aa58c135e488e6b40a388dad9d5}{memoryType}, &memFlags);
\textcolor{keywordflow}{if}((memFlags & VK\_MEMORY\_PROPERTY\_HOST\_VISIBLE\_BIT) == 0)
\{
    \textcolor{comment}{// Allocation ended up in mappable memory. You can map it and access it directly.}
    \textcolor{keywordtype}{void}* mappedData;
    vmaMapMemory(allocator, alloc, &mappedData);
    memcpy(mappedData, &constantBufferData, \textcolor{keyword}{sizeof}(constantBufferData));
    vmaUnmapMemory(allocator, alloc);
\}
\textcolor{keywordflow}{else}
\{
    \textcolor{comment}{// Allocation ended up in non-mappable memory.}
    \textcolor{comment}{// You need to create CPU-side buffer in VMA\_MEMORY\_USAGE\_CPU\_ONLY and make a transfer.}
\}
\end{DoxyCode}


You can even use \#\+V\+M\+A\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+M\+A\+P\+P\+E\+D\+\_\+\+B\+IT flag while creating allocations that are not necessarily {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE} (e.\+g. using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+O\+N\+LY). If the allocation ends up in memory type that is {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE}, it will be persistently mapped and you can use it directly. If not, the flag is just ignored. Example\+:


\begin{DoxyCode}
VkBufferCreateInfo bufCreateInfo = \{ VK\_STRUCTURE\_TYPE\_BUFFER\_CREATE\_INFO \};
bufCreateInfo.size = \textcolor{keyword}{sizeof}(ConstantBuffer);
bufCreateInfo.usage = VK\_BUFFER\_USAGE\_UNIFORM\_BUFFER\_BIT | VK\_BUFFER\_USAGE\_TRANSFER\_DST\_BIT;

\hyperlink{structVmaAllocationCreateInfo}{VmaAllocationCreateInfo} allocCreateInfo = \{\};
allocCreateInfo.\hyperlink{structVmaAllocationCreateInfo_accb8b06b1f677d858cb9af20705fa910}{usage} = VMA\_MEMORY\_USAGE\_GPU\_ONLY;
allocCreateInfo.\hyperlink{structVmaAllocationCreateInfo_add09658ac14fe290ace25470ddd6d41b}{flags} = VMA\_ALLOCATION\_CREATE\_MAPPED\_BIT;

VkBuffer buf;
\hyperlink{structVmaAllocation}{VmaAllocation} alloc;
\hyperlink{structVmaAllocationInfo}{VmaAllocationInfo} allocInfo;
vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);

\textcolor{keywordflow}{if}(allocInfo.\hyperlink{structVmaAllocationInfo_adc507656149c04de7ed95d0042ba2a13}{pUserData} != \textcolor{keyword}{nullptr})
\{
    \textcolor{comment}{// Allocation ended up in mappable memory.}
    \textcolor{comment}{// It's persistently mapped. You can access it directly.}
    memcpy(allocInfo.\hyperlink{structVmaAllocationInfo_a5eeffbe2d2f30f53370ff14aefbadbe2}{pMappedData}, &constantBufferData, \textcolor{keyword}{sizeof}(constantBufferData));
\}
\textcolor{keywordflow}{else}
\{
    \textcolor{comment}{// Allocation ended up in non-mappable memory.}
    \textcolor{comment}{// You need to create CPU-side buffer in VMA\_MEMORY\_USAGE\_CPU\_ONLY and make a transfer.}
\}
\end{DoxyCode}
 