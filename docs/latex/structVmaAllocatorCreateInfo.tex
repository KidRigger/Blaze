\hypertarget{structVmaAllocatorCreateInfo}{}\section{Vma\+Allocator\+Create\+Info Struct Reference}
\label{structVmaAllocatorCreateInfo}\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}


Description of a Allocator to be created.  




{\ttfamily \#include $<$vk\+\_\+mem\+\_\+alloc.\+h$>$}



Collaboration diagram for Vma\+Allocator\+Create\+Info\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structVmaAllocatorCreateInfo__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{structVmaAllocatorCreateInfo_a392ea2ecbaff93f91a7c49f735ad4346}\label{structVmaAllocatorCreateInfo_a392ea2ecbaff93f91a7c49f735ad4346}} 
Vma\+Allocator\+Create\+Flags \hyperlink{structVmaAllocatorCreateInfo_a392ea2ecbaff93f91a7c49f735ad4346}{flags}
\begin{DoxyCompactList}\small\item\em Flags for created allocator. Use \#\+Vma\+Allocator\+Create\+Flag\+Bits enum. \end{DoxyCompactList}\item 
Vk\+Physical\+Device \hyperlink{structVmaAllocatorCreateInfo_a08230f04ae6ccf8a78150a9e829a7156}{physical\+Device}
\begin{DoxyCompactList}\small\item\em Vulkan physical device. \end{DoxyCompactList}\item 
Vk\+Device \hyperlink{structVmaAllocatorCreateInfo_ad924ddd77b04039c88d0c09b0ffcd500}{device}
\begin{DoxyCompactList}\small\item\em Vulkan device. \end{DoxyCompactList}\item 
Vk\+Device\+Size \hyperlink{structVmaAllocatorCreateInfo_a8e4714298e3121cdd8b214a1ae7a637a}{preferred\+Large\+Heap\+Block\+Size}
\begin{DoxyCompactList}\small\item\em Preferred size of a single {\ttfamily Vk\+Device\+Memory} block to be allocated from large heaps $>$ 1 GiB. Optional. \end{DoxyCompactList}\item 
const Vk\+Allocation\+Callbacks $\ast$ \hyperlink{structVmaAllocatorCreateInfo_a6e409087e3be55400d0e4ccbe43c608d}{p\+Allocation\+Callbacks}
\begin{DoxyCompactList}\small\item\em Custom C\+PU memory allocation callbacks. Optional. \end{DoxyCompactList}\item 
const \hyperlink{structVmaDeviceMemoryCallbacks}{Vma\+Device\+Memory\+Callbacks} $\ast$ \hyperlink{structVmaAllocatorCreateInfo_af1380969b5e1ea4c3184a877892d260e}{p\+Device\+Memory\+Callbacks}
\begin{DoxyCompactList}\small\item\em Informative callbacks for {\ttfamily vk\+Allocate\+Memory}, {\ttfamily vk\+Free\+Memory}. Optional. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{structVmaAllocatorCreateInfo_a21ea188dd212b8171cb9ecbed4a2a3a7}{frame\+In\+Use\+Count}
\begin{DoxyCompactList}\small\item\em Maximum number of additional frames that are in use at the same time as current frame. \end{DoxyCompactList}\item 
const Vk\+Device\+Size $\ast$ \hyperlink{structVmaAllocatorCreateInfo_a31c192aa6cbffa33279f6d9f0c47c44b}{p\+Heap\+Size\+Limit}
\begin{DoxyCompactList}\small\item\em Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap. \end{DoxyCompactList}\item 
const \hyperlink{structVmaVulkanFunctions}{Vma\+Vulkan\+Functions} $\ast$ \hyperlink{structVmaAllocatorCreateInfo_a3dc197be3227da7338b1643f70db36bd}{p\+Vulkan\+Functions}
\begin{DoxyCompactList}\small\item\em Pointers to Vulkan functions. Can be null if you leave define {\ttfamily V\+M\+A\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+V\+U\+L\+K\+A\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS 1}. \end{DoxyCompactList}\item 
const \hyperlink{structVmaRecordSettings}{Vma\+Record\+Settings} $\ast$ \hyperlink{structVmaAllocatorCreateInfo_ace2aa4877b16a42b0b7673d4e26000ee}{p\+Record\+Settings}
\begin{DoxyCompactList}\small\item\em Parameters for recording of V\+MA calls. Can be null. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Description of a Allocator to be created. 

\subsection{Member Data Documentation}
\mbox{\Hypertarget{structVmaAllocatorCreateInfo_ad924ddd77b04039c88d0c09b0ffcd500}\label{structVmaAllocatorCreateInfo_ad924ddd77b04039c88d0c09b0ffcd500}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!device@{device}}
\index{device@{device}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{device}{device}}
{\footnotesize\ttfamily Vk\+Device Vma\+Allocator\+Create\+Info\+::device}



Vulkan device. 

It must be valid throughout whole lifetime of created allocator. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_a21ea188dd212b8171cb9ecbed4a2a3a7}\label{structVmaAllocatorCreateInfo_a21ea188dd212b8171cb9ecbed4a2a3a7}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!frame\+In\+Use\+Count@{frame\+In\+Use\+Count}}
\index{frame\+In\+Use\+Count@{frame\+In\+Use\+Count}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{frame\+In\+Use\+Count}{frameInUseCount}}
{\footnotesize\ttfamily uint32\+\_\+t Vma\+Allocator\+Create\+Info\+::frame\+In\+Use\+Count}



Maximum number of additional frames that are in use at the same time as current frame. 

This value is used only when you make allocations with V\+M\+A\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+C\+A\+N\+\_\+\+B\+E\+C\+O\+M\+E\+\_\+\+L\+O\+S\+T\+\_\+\+B\+IT flag. Such allocation cannot become lost if allocation.\+last\+Use\+Frame\+Index $>$= allocator.\+current\+Frame\+Index -\/ frame\+In\+Use\+Count.

For example, if you double-\/buffer your command buffers, so resources used for rendering in previous frame may still be in use by the G\+PU at the moment you allocate resources needed for the current frame, set this value to 1.

If you want to allow any allocations other than used in the current frame to become lost, set this value to 0. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_a6e409087e3be55400d0e4ccbe43c608d}\label{structVmaAllocatorCreateInfo_a6e409087e3be55400d0e4ccbe43c608d}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!p\+Allocation\+Callbacks@{p\+Allocation\+Callbacks}}
\index{p\+Allocation\+Callbacks@{p\+Allocation\+Callbacks}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{p\+Allocation\+Callbacks}{pAllocationCallbacks}}
{\footnotesize\ttfamily const Vk\+Allocation\+Callbacks$\ast$ Vma\+Allocator\+Create\+Info\+::p\+Allocation\+Callbacks}



Custom C\+PU memory allocation callbacks. Optional. 

Optional, can be null. When specified, will also be used for all C\+P\+U-\/side memory allocations. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_af1380969b5e1ea4c3184a877892d260e}\label{structVmaAllocatorCreateInfo_af1380969b5e1ea4c3184a877892d260e}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!p\+Device\+Memory\+Callbacks@{p\+Device\+Memory\+Callbacks}}
\index{p\+Device\+Memory\+Callbacks@{p\+Device\+Memory\+Callbacks}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{p\+Device\+Memory\+Callbacks}{pDeviceMemoryCallbacks}}
{\footnotesize\ttfamily const \hyperlink{structVmaDeviceMemoryCallbacks}{Vma\+Device\+Memory\+Callbacks}$\ast$ Vma\+Allocator\+Create\+Info\+::p\+Device\+Memory\+Callbacks}



Informative callbacks for {\ttfamily vk\+Allocate\+Memory}, {\ttfamily vk\+Free\+Memory}. Optional. 

Optional, can be null. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_a31c192aa6cbffa33279f6d9f0c47c44b}\label{structVmaAllocatorCreateInfo_a31c192aa6cbffa33279f6d9f0c47c44b}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!p\+Heap\+Size\+Limit@{p\+Heap\+Size\+Limit}}
\index{p\+Heap\+Size\+Limit@{p\+Heap\+Size\+Limit}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{p\+Heap\+Size\+Limit}{pHeapSizeLimit}}
{\footnotesize\ttfamily const Vk\+Device\+Size$\ast$ Vma\+Allocator\+Create\+Info\+::p\+Heap\+Size\+Limit}



Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap. 

If not N\+U\+LL, it must be a pointer to an array of {\ttfamily Vk\+Physical\+Device\+Memory\+Properties\+::memory\+Heap\+Count} elements, defining limit on maximum number of bytes that can be allocated out of particular Vulkan memory heap.

Any of the elements may be equal to {\ttfamily V\+K\+\_\+\+W\+H\+O\+L\+E\+\_\+\+S\+I\+ZE}, which means no limit on that heap. This is also the default in case of {\ttfamily p\+Heap\+Size\+Limit} = N\+U\+LL.

If there is a limit defined for a heap\+:


\begin{DoxyItemize}
\item If user tries to allocate more memory from that heap using this allocator, the allocation fails with {\ttfamily V\+K\+\_\+\+E\+R\+R\+O\+R\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+M\+E\+M\+O\+RY}.
\item If the limit is smaller than heap size reported in {\ttfamily Vk\+Memory\+Heap\+::size}, the value of this limit will be reported instead when using vma\+Get\+Memory\+Properties().
\end{DoxyItemize}

Warning! Using this feature may not be equivalent to installing a G\+PU with smaller amount of memory, because graphics driver doesn\textquotesingle{}t necessary fail new allocations with {\ttfamily V\+K\+\_\+\+E\+R\+R\+O\+R\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+M\+E\+M\+O\+RY} result when memory capacity is exceeded. It may return success and just silently migrate some device memory blocks to system R\+AM. This driver behavior can also be controlled using V\+K\+\_\+\+A\+M\+D\+\_\+memory\+\_\+overallocation\+\_\+behavior extension. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_a08230f04ae6ccf8a78150a9e829a7156}\label{structVmaAllocatorCreateInfo_a08230f04ae6ccf8a78150a9e829a7156}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!physical\+Device@{physical\+Device}}
\index{physical\+Device@{physical\+Device}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{physical\+Device}{physicalDevice}}
{\footnotesize\ttfamily Vk\+Physical\+Device Vma\+Allocator\+Create\+Info\+::physical\+Device}



Vulkan physical device. 

It must be valid throughout whole lifetime of created allocator. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_ace2aa4877b16a42b0b7673d4e26000ee}\label{structVmaAllocatorCreateInfo_ace2aa4877b16a42b0b7673d4e26000ee}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!p\+Record\+Settings@{p\+Record\+Settings}}
\index{p\+Record\+Settings@{p\+Record\+Settings}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{p\+Record\+Settings}{pRecordSettings}}
{\footnotesize\ttfamily const \hyperlink{structVmaRecordSettings}{Vma\+Record\+Settings}$\ast$ Vma\+Allocator\+Create\+Info\+::p\+Record\+Settings}



Parameters for recording of V\+MA calls. Can be null. 

If not null, it enables recording of calls to V\+MA functions to a file. If support for recording is not enabled using {\ttfamily V\+M\+A\+\_\+\+R\+E\+C\+O\+R\+D\+I\+N\+G\+\_\+\+E\+N\+A\+B\+L\+ED} macro, creation of the allocator object fails with {\ttfamily V\+K\+\_\+\+E\+R\+R\+O\+R\+\_\+\+F\+E\+A\+T\+U\+R\+E\+\_\+\+N\+O\+T\+\_\+\+P\+R\+E\+S\+E\+NT}. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_a8e4714298e3121cdd8b214a1ae7a637a}\label{structVmaAllocatorCreateInfo_a8e4714298e3121cdd8b214a1ae7a637a}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!preferred\+Large\+Heap\+Block\+Size@{preferred\+Large\+Heap\+Block\+Size}}
\index{preferred\+Large\+Heap\+Block\+Size@{preferred\+Large\+Heap\+Block\+Size}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{preferred\+Large\+Heap\+Block\+Size}{preferredLargeHeapBlockSize}}
{\footnotesize\ttfamily Vk\+Device\+Size Vma\+Allocator\+Create\+Info\+::preferred\+Large\+Heap\+Block\+Size}



Preferred size of a single {\ttfamily Vk\+Device\+Memory} block to be allocated from large heaps $>$ 1 GiB. Optional. 

Set to 0 to use default, which is currently 256 MiB. \mbox{\Hypertarget{structVmaAllocatorCreateInfo_a3dc197be3227da7338b1643f70db36bd}\label{structVmaAllocatorCreateInfo_a3dc197be3227da7338b1643f70db36bd}} 
\index{Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}!p\+Vulkan\+Functions@{p\+Vulkan\+Functions}}
\index{p\+Vulkan\+Functions@{p\+Vulkan\+Functions}!Vma\+Allocator\+Create\+Info@{Vma\+Allocator\+Create\+Info}}
\subsubsection{\texorpdfstring{p\+Vulkan\+Functions}{pVulkanFunctions}}
{\footnotesize\ttfamily const \hyperlink{structVmaVulkanFunctions}{Vma\+Vulkan\+Functions}$\ast$ Vma\+Allocator\+Create\+Info\+::p\+Vulkan\+Functions}



Pointers to Vulkan functions. Can be null if you leave define {\ttfamily V\+M\+A\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+V\+U\+L\+K\+A\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS 1}. 

If you leave define {\ttfamily V\+M\+A\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+V\+U\+L\+K\+A\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS 1} in configuration section, you can pass null as this member, because the library will fetch pointers to Vulkan functions internally in a static way, like\+: \begin{DoxyVerb}vulkanFunctions.vkAllocateMemory = &vkAllocateMemory;
\end{DoxyVerb}


Fill this member if you want to provide your own pointers to Vulkan functions, e.\+g. fetched using {\ttfamily vk\+Get\+Instance\+Proc\+Addr()} and {\ttfamily vk\+Get\+Device\+Proc\+Addr()}. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Blaze/thirdparty/vma/vk\+\_\+mem\+\_\+alloc.\+h\end{DoxyCompactItemize}
