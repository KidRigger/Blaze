See also slides from talk\+: \href{https://www.gdcvault.com/play/1025458/Advanced-Graphics-Techniques-Tutorial-New}{\tt Sawicki, Adam. Advanced Graphics Techniques Tutorial\+: Memory management in Vulkan and D\+X12. Game Developers Conference, 2018}\hypertarget{usage_patterns_usage_patterns_common_mistakes}{}\section{Common mistakes}\label{usage_patterns_usage_patterns_common_mistakes}
{\bfseries Use of C\+P\+U\+\_\+\+T\+O\+\_\+\+G\+PU instead of C\+P\+U\+\_\+\+O\+N\+LY memory}

\#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+T\+O\+\_\+\+G\+PU is recommended only for resources that will be mapped and written by the C\+PU, as well as read directly by the G\+PU -\/ like some buffers or textures updated every frame (dynamic). If you create a staging copy of a resource to be written by C\+PU and then used as a source of transfer to another resource placed in the G\+PU memory, that staging resource should be created with \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+O\+N\+LY. Please read the descriptions of these enums carefully for details.

{\bfseries Unnecessary use of custom pools}

\hyperlink{custom_memory_pools}{Custom memory pools} may be useful for special purposes -\/ when you want to keep certain type of resources separate e.\+g. to reserve minimum amount of memory for them, limit maximum amount of memory they can occupy, or make some of them push out the other through the mechanism of \hyperlink{lost_allocations}{Lost allocations}. For most resources this is not needed and so it is not recommended to create \hyperlink{structVmaPool}{Vma\+Pool} objects and allocations out of them. Allocating from the default pool is sufficient.\hypertarget{usage_patterns_usage_patterns_simple}{}\section{Simple patterns}\label{usage_patterns_usage_patterns_simple}
\hypertarget{usage_patterns_usage_patterns_simple_render_targets}{}\subsection{Render targets}\label{usage_patterns_usage_patterns_simple_render_targets}
{\bfseries When\+:} Any resources that you frequently write and read on G\+PU, e.\+g. images used as color attachments (aka \char`\"{}render targets\char`\"{}), depth-\/stencil attachments, images/buffers used as storage image/buffer (aka \char`\"{}\+Unordered Access View (\+U\+A\+V)\char`\"{}).

{\bfseries What to do\+:} Create them in video memory that is fastest to access from G\+PU using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+O\+N\+LY.

Consider using \hyperlink{vk_khr_dedicated_allocation}{V\+K\+\_\+\+K\+H\+R\+\_\+dedicated\+\_\+allocation} extension and/or manually creating them as dedicated allocations using \#\+V\+M\+A\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+D\+E\+D\+I\+C\+A\+T\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+B\+IT, especially if they are large or if you plan to destroy and recreate them e.\+g. when display resolution changes. Prefer to create such resources first and all other G\+PU resources (like textures and vertex buffers) later.\hypertarget{usage_patterns_usage_patterns_simple_immutable_resources}{}\subsection{Immutable resources}\label{usage_patterns_usage_patterns_simple_immutable_resources}
{\bfseries When\+:} Any resources that you fill on C\+PU only once (aka \char`\"{}immutable\char`\"{}) or infrequently and then read frequently on G\+PU, e.\+g. textures, vertex and index buffers, constant buffers that don\textquotesingle{}t change often.

{\bfseries What to do\+:} Create them in video memory that is fastest to access from G\+PU using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+O\+N\+LY.

To initialize content of such resource, create a C\+P\+U-\/side (aka \char`\"{}staging\char`\"{}) copy of it in system memory -\/ \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+O\+N\+LY, map it, fill it, and submit a transfer from it to the G\+PU resource. You can keep the staging copy if you need it for another upload transfer in the future. If you don\textquotesingle{}t, you can destroy it or reuse this buffer for uploading different resource after the transfer finishes.

Prefer to create just buffers in system memory rather than images, even for uploading textures. Use {\ttfamily vk\+Cmd\+Copy\+Buffer\+To\+Image()}. Dont use images with {\ttfamily V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+T\+I\+L\+I\+N\+G\+\_\+\+L\+I\+N\+E\+AR}.\hypertarget{usage_patterns_usage_patterns_dynamic_resources}{}\subsection{Dynamic resources}\label{usage_patterns_usage_patterns_dynamic_resources}
{\bfseries When\+:} Any resources that change frequently (aka \char`\"{}dynamic\char`\"{}), e.\+g. every frame or every draw call, written on C\+PU, read on G\+PU.

{\bfseries What to do\+:} Create them using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+T\+O\+\_\+\+G\+PU. You can map it and write to it directly on C\+PU, as well as read from it on G\+PU.

This is a more complex situation. Different solutions are possible, and the best one depends on specific G\+PU type, but you can use this simple approach for the start. Prefer to write to such resource sequentially (e.\+g. using {\ttfamily memcpy}). Don\textquotesingle{}t perform random access or any reads from it on C\+PU, as it may be very slow.\hypertarget{usage_patterns_usage_patterns_readback}{}\subsection{Readback}\label{usage_patterns_usage_patterns_readback}
{\bfseries When\+:} Resources that contain data written by G\+PU that you want to read back on C\+PU, e.\+g. results of some computations.

{\bfseries What to do\+:} Create them using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+T\+O\+\_\+\+C\+PU. You can write to them directly on G\+PU, as well as map and read them on C\+PU.\hypertarget{usage_patterns_usage_patterns_advanced}{}\section{Advanced patterns}\label{usage_patterns_usage_patterns_advanced}
\hypertarget{usage_patterns_usage_patterns_integrated_graphics}{}\subsection{Detecting integrated graphics}\label{usage_patterns_usage_patterns_integrated_graphics}
You can support integrated graphics (like Intel HD Graphics, A\+MD A\+PU) better by detecting it in Vulkan. To do it, call {\ttfamily vk\+Get\+Physical\+Device\+Properties()}, inspect {\ttfamily Vk\+Physical\+Device\+Properties\+::device\+Type} and look for {\ttfamily V\+K\+\_\+\+P\+H\+Y\+S\+I\+C\+A\+L\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+N\+T\+E\+G\+R\+A\+T\+E\+D\+\_\+\+G\+PU}. When you find it, you can assume that memory is unified and all memory types are comparably fast to access from G\+PU, regardless of {\ttfamily V\+K\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+P\+R\+O\+P\+E\+R\+T\+Y\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+B\+IT}.

You can then sum up sizes of all available memory heaps and treat them as useful for your G\+PU resources, instead of only {\ttfamily D\+E\+V\+I\+C\+E\+\_\+\+L\+O\+C\+AL} ones. You can also prefer to create your resources in memory types that are {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE} to map them directly instead of submitting explicit transfer (see below).\hypertarget{usage_patterns_usage_patterns_direct_vs_transfer}{}\subsection{Direct access versus transfer}\label{usage_patterns_usage_patterns_direct_vs_transfer}
For resources that you frequently write on C\+PU and read on G\+PU, many solutions are possible\+:


\begin{DoxyEnumerate}
\item Create one copy in video memory using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+O\+N\+LY, second copy in system memory using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+O\+N\+LY and submit explicit tranfer each time.
\item Create just single copy using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+T\+O\+\_\+\+G\+PU, map it and fill it on C\+PU, read it directly on G\+PU.
\item Create just single copy using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+C\+P\+U\+\_\+\+O\+N\+LY, map it and fill it on C\+PU, read it directly on G\+PU.
\end{DoxyEnumerate}

Which solution is the most efficient depends on your resource and especially on the G\+PU. It is best to measure it and then make the decision. Some general recommendations\+:


\begin{DoxyItemize}
\item On integrated graphics use (2) or (3) to avoid unnecesary time and memory overhead related to using a second copy and making transfer.
\item For small resources (e.\+g. constant buffers) use (2). Discrete A\+MD cards have special 256 MiB pool of video memory that is directly mappable. Even if the resource ends up in system memory, its data may be cached on G\+PU after first fetch over P\+C\+Ie bus.
\item For larger resources (e.\+g. textures), decide between (1) and (2). You may want to differentiate N\+V\+I\+D\+IA and A\+MD, e.\+g. by looking for memory type that is both {\ttfamily D\+E\+V\+I\+C\+E\+\_\+\+L\+O\+C\+AL} and {\ttfamily H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE}. When you find it, use (2), otherwise use (1).
\end{DoxyItemize}

Similarly, for resources that you frequently write on G\+PU and read on C\+PU, multiple solutions are possible\+:


\begin{DoxyEnumerate}
\item Create one copy in video memory using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+O\+N\+LY, second copy in system memory using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+T\+O\+\_\+\+C\+PU and submit explicit tranfer each time.
\item Create just single copy using \#\+V\+M\+A\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+A\+G\+E\+\_\+\+G\+P\+U\+\_\+\+T\+O\+\_\+\+C\+PU, write to it directly on G\+PU, map it and read it on C\+PU.
\end{DoxyEnumerate}

You should take some measurements to decide which option is faster in case of your specific resource.

If you don\textquotesingle{}t want to specialize your code for specific types of G\+P\+Us, you can still make an simple optimization for cases when your resource ends up in mappable memory to use it directly in this case instead of creating C\+P\+U-\/side staging copy. For details see \hyperlink{memory_mapping_memory_mapping_finding_if_memory_mappable}{Finding out if memory is mappable}. 