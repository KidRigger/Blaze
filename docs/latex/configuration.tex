Please check \char`\"{}\+C\+O\+N\+F\+I\+G\+U\+R\+A\+T\+I\+O\+N S\+E\+C\+T\+I\+O\+N\char`\"{} in the code to find macros that you can define before each include of this file or change directly in this file to provide your own implementation of basic facilities like assert, {\ttfamily min()} and {\ttfamily max()} functions, mutex, atomic etc. The library uses its own implementation of containers by default, but you can switch to using S\+TL containers instead.

For example, define {\ttfamily V\+M\+A\+\_\+\+A\+S\+S\+E\+R\+T(expr)} before including the library to provide custom implementation of the assertion, compatible with your project. By default it is defined to standard C {\ttfamily assert(expr)} in {\ttfamily \+\_\+\+D\+E\+B\+UG} configuration and empty otherwise.\hypertarget{configuration_config_Vulkan_functions}{}\section{Pointers to Vulkan functions}\label{configuration_config_Vulkan_functions}
The library uses Vulkan functions straight from the {\ttfamily vulkan.\+h} header by default. If you want to provide your own pointers to these functions, e.\+g. fetched using {\ttfamily vk\+Get\+Instance\+Proc\+Addr()} and {\ttfamily vk\+Get\+Device\+Proc\+Addr()}\+:


\begin{DoxyEnumerate}
\item Define {\ttfamily V\+M\+A\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+V\+U\+L\+K\+A\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS 0}.
\item Provide valid pointers through \hyperlink{structVmaAllocatorCreateInfo_a3dc197be3227da7338b1643f70db36bd}{Vma\+Allocator\+Create\+Info\+::p\+Vulkan\+Functions}.
\end{DoxyEnumerate}\hypertarget{configuration_custom_memory_allocator}{}\section{Custom host memory allocator}\label{configuration_custom_memory_allocator}
If you use custom allocator for C\+PU memory rather than default operator {\ttfamily new} and {\ttfamily delete} from C++, you can make this library using your allocator as well by filling optional member \hyperlink{structVmaAllocatorCreateInfo_a6e409087e3be55400d0e4ccbe43c608d}{Vma\+Allocator\+Create\+Info\+::p\+Allocation\+Callbacks}. These functions will be passed to Vulkan, as well as used by the library itself to make any C\+P\+U-\/side allocations.\hypertarget{configuration_allocation_callbacks}{}\section{Device memory allocation callbacks}\label{configuration_allocation_callbacks}
The library makes calls to {\ttfamily vk\+Allocate\+Memory()} and {\ttfamily vk\+Free\+Memory()} internally. You can setup callbacks to be informed about these calls, e.\+g. for the purpose of gathering some statistics. To do it, fill optional member \hyperlink{structVmaAllocatorCreateInfo_af1380969b5e1ea4c3184a877892d260e}{Vma\+Allocator\+Create\+Info\+::p\+Device\+Memory\+Callbacks}.\hypertarget{configuration_heap_memory_limit}{}\section{Device heap memory limit}\label{configuration_heap_memory_limit}
When device memory of certain heap runs out of free space, new allocations may fail (returning error code) or they may succeed, silently pushing some existing memory blocks from G\+PU V\+R\+AM to system R\+AM (which degrades performance). This behavior is implementation-\/dependant -\/ it depends on G\+PU vendor and graphics driver.

On A\+MD cards it can be controlled while creating Vulkan device object by using V\+K\+\_\+\+A\+M\+D\+\_\+memory\+\_\+overallocation\+\_\+behavior extension, if available.

Alternatively, if you want to test how your program behaves with limited amount of Vulkan device memory available without switching your graphics card to one that really has smaller V\+R\+AM, you can use a feature of this library intended for this purpose. To do it, fill optional member \hyperlink{structVmaAllocatorCreateInfo_a31c192aa6cbffa33279f6d9f0c47c44b}{Vma\+Allocator\+Create\+Info\+::p\+Heap\+Size\+Limit}. 